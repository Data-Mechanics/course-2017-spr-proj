<!DOCTYPE html>
<html>
<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <form>
        <span style="color:dimgrey" id="title">Statistic Analysis: </span><select id="geo" style="width:200px;">
            <option value='1'>Hyde Park(1)</option>
            <option value='2'>Hyde Park(2)</option>
            <option value='3'>West Roxbury(3)</option>
            <option value='4'>West Roxbury(4)</option>
            <option value='5'>Hyde Park(5)</option>
            <option value='6'>Mattapan(6)</option>
            <option value='7'>West Roxbury(7)</option>
            <option value='8'>West Roxbury(8)</option>
            <option value='9'>Hyde Park(9)</option>
            <option value='10'>Mattapan(10)</option>
            <option value='11'>Mattapan(11)</option>
            <option value='12'>Dorchester(12)</option>
            <option value='13'>West Roxbury(13)</option>
            <option value='14'>West Roxbury(14)</option>
            <option value='15'>Roslindale(15)</option>
            <option value='16'>Dorchester(16)</option>
            <option value='17'>Dorchester(17)</option>
            <option value='18'>Dorchester(18)</option>
            <option disabled value='19'>Block19</option>
            <option disabled value='20'>Block20</option>
            <option value='21'>Jamaica Plain(21)</option>
            <option value='22'>Roxbury(22)</option>
            <option value='23'>Dorchester(23)</option>
            <option disabled value='24'>Block24</option>
            <option value='25'>Jamaica Plain(25)</option>
            <option disabled value='26'>Block26</option>
            <option disabled value='27'>Block27</option>
            <option disabled value='28'>Block28</option>
            <option disabled value='29'>Block29</option>
            <option value='30'>Brighton(30)</option>
            <option value='31'>Brighton(31)</option>
            <option disabled value='32'>Block32</option>
            <option disabled value='33'>Block33</option>
            <option value='34'>South End(34)</option>
            <option value='35'>South Boston(35)</option>
            <option value='36'>South Boston(36)</option>
            <option value='37'>Brighton(37)</option>
            <option value='38'>Brighton(38)</option>
            <option value='39'>Allston(39)</option>
            <option value='40'>Fenway/Kenmore(40)</option>
            <option disabled value='41'>Block41</option>
            <option value='42'>Downtown(42)</option>
            <option value='43'>East Boston(43)</option>
            <option disabled value='44'>Block44</option>
            <option value='45'>Charlestown(45)</option>
            <option value='46'>East Boston(46)</option>
            <option value='47'>East Boston(47)</option>
            <option value='48'>East Boston(48)</option>
            <option value='49'>Charlestown(49)</option>
            <option value='50'>East Boston(50)</option>
            <option value='51'>East Boston(51)</option>
            <option value='52'>East Boston(52)</option>
        </select>
    </form>
    <div id="wrap" style="max-width:960px;">
        <div id="pie-chart" style="float: left; width:510px;margin:0;"></div>
        <div id="graph" style="float: left; width:450px;margin:0;"></div>
        <span class="prepaired" style='color:grey;font-size:0.625em;'>Used template provided by: Nathan Dobie for UNM Bureau of Business and Economic Research</span>
        <br />
    </div>
    <script type="text/javascript">

        d3.select(self.frameElement).attr("height", "480px")

        var div = d3.select("body").append("div").attr("class", "toolTip");

        var w = 510;
        var h = 390;
        var r = 130;
        var ir = 78;
        var textOffset = 24;
        var tweenDuration = 1050;

        //OBJECTS TO BE POPULATED WITH DATA LATER
        var lines, valueLabels, nameLabels;
        var pieData = [];
        var oldPieData = [];
        var filteredPieData = [];

        //D3 helper function to populate pie slice parameters from array data
        var donut = d3.layout.pie().value(function (d) {
            return d.emp;
        }).sort(null);

        ////D3 helper function to create colors from an ordinal scale
        //var color = d3.scale.category20c();
        var color = d3.scale.ordinal()
            .range(['#6baed6', '#aaa']);

        //D3 helper function to draw arcs, populates parameter "d" in path object
        var arc = d3.svg.arc()
          .startAngle(function (d) { return d.startAngle; })
          .endAngle(function (d) { return d.endAngle; })
          .innerRadius(ir)
          .outerRadius(r);

        function formatMoney(num) {
            return num.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,")
        };

        var vis = d3.select("#pie-chart").append("svg:svg")
          .attr("width", w)
          .attr("height", h);

        //GROUP FOR ARCS/PATHS
        var arc_group = vis.append("svg:g")
          .attr("class", "arc")
          .attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

        //GROUP FOR LABELS
        var label_group = vis.append("svg:g")
          .attr("class", "label_group")
          .attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

        //GROUP FOR CENTER TEXT
        var center_group = vis.append("svg:g")
          .attr("class", "center_group")
          .attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

        //WHITE CIRCLE BEHIND LABELS
        var whiteCircle = center_group.append("svg:circle")
          .attr("fill", "white")
          .attr("r", ir);

        function type(d) {
            d.emp = +d.emp;
            return d;
        };

        d3.csv("/static/crimeTotal.csv", type, function (error, dataI) {
            d3.selectAll("#geo")
               .on("change", update);

            function update() {
                dataI.value = dataI.emp;
                var I = document.getElementById('geo').selectedIndex
                    , select = document.getElementById('geo')[I].value;

                data = dataI.filter(function (d) { return d.area == select; });

                oldPieData = filteredPieData;
                pieData = donut(data);
                var sliceProportion = 0; //size of this slice
                filteredPieData = pieData.filter(filterData);

                function filterData(element, index, array) {
                    element.emp = data[index].emp;
                    element.ind = data[index].ind;
                    element.label = data[index].label;
                    sliceProportion += element.emp;
                    return (element.emp >= 0)
                }

                //DRAW ARC PATHS
                paths = arc_group.selectAll("path").data(filteredPieData);
                paths.enter().append("svg:path")
                  .attr("stroke", "white")
                  .attr("stroke-width", 0.5)
                  .attr("fill", function (d, i) { return color(i); })
                  .transition()
                    .duration(tweenDuration)
                    .attrTween("d", pieTween);
                paths
                  .transition()
                    .duration(tweenDuration)
                    .attrTween("d", pieTween);
                paths.exit()
                  .transition()
                    .duration(tweenDuration)
                    .attrTween("d", removePieTween)
                  .remove();

                paths.on("mousemove", function (d) {
                    div.style("left", d3.event.pageX + 10 + "px");
                    div.style("top", d3.event.pageY - 25 + "px");
                    div.style("display", "inline-block");
                    div.html(d.label + ': ' + (d.ind) + "<br>" + 'Covered Employment: ' + (formatMoney(d.emp)));
                });

                paths.on("mouseout", function (d) {
                    div.style("display", "none");
                });

                //DRAW TICK MARK LINES FOR LABELS
                lines = label_group.selectAll("line").data(filteredPieData);
                lines.enter().append("svg:line")
                  .attr("x1", 0)
                  .attr("x2", 0)
                  .attr("y1", -r - 3)
                  .attr("y2", -r - 15)
                  .attr("stroke", "gray")
                  .attr("transform", function (d) {
                      return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
                  });
                lines.transition()
                  .duration(tweenDuration)
                  .attr("transform", function (d) {
                      return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
                  });
                lines.exit().remove();

                //DRAW LABELS WITH PERCENTAGE VALUES
                valueLabels = label_group.selectAll("text.value").data(filteredPieData)
                  .attr("dy", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
                          return 5;
                      } else {
                          return -7;
                      }
                  })
                  .attr("text-anchor", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                          return "beginning";
                      } else {
                          return "end";
                      }
                  })
                  .text(function (d) {
                      var percentage = (d.value / sliceProportion) * 100;
                      return percentage.toFixed(1) + "%";
                  });

                valueLabels.enter().append("svg:text")
                  .attr("class", "value")
                  .attr("transform", function (d) {
                      return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
                  })
                  .attr("dy", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
                          return 5;
                      } else {
                          return -7;
                      }
                  })
                  .attr("text-anchor", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                          return "beginning";
                      } else {
                          return "end";
                      }
                  }).text(function (d) {
                      var percentage = (d.value / sliceProportion) * 100;
                      return percentage.toFixed(1) + "%";
                  });

                valueLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

                valueLabels.exit().remove();

                //DRAW LABELS WITH ENTITY NAMES
                nameLabels = label_group.selectAll("text.units").data(filteredPieData)
                  .attr("dy", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
                          return 17;
                      } else {
                          return 5;
                      }
                  })
                  .attr("text-anchor", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                          return "beginning";
                      } else {
                          return "end";
                      }
                  }).text(function (d) {
                      return d.ind;
                  });

                nameLabels.enter().append("svg:text")
                  .attr("class", "units")
                  .attr("transform", function (d) {
                      return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
                  })
                  .attr("dy", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
                          return 17;
                      } else {
                          return 5;
                      }
                  })
                  .attr("text-anchor", function (d) {
                      if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                          return "beginning";
                      } else {
                          return "end";
                      }
                  }).text(function (d) {
                      return d.ind;
                  });

                nameLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

                nameLabels.exit().remove();
                updateBars(); //Notice the bar update gets called here and later, this actually works to create the neat into animation that only occurs on page load, easier than righting a custom delay function
            }

            // Interpolate the arcs in data space.
            function pieTween(d, i) {
                var s0;
                var e0;
                if (oldPieData[i]) {
                    s0 = oldPieData[i].startAngle;
                    e0 = oldPieData[i].endAngle;
                } else if (!(oldPieData[i]) && oldPieData[i - 1]) {
                    s0 = oldPieData[i - 1].endAngle;
                    e0 = oldPieData[i - 1].endAngle;
                } else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
                    s0 = oldPieData[oldPieData.length - 1].endAngle;
                    e0 = oldPieData[oldPieData.length - 1].endAngle;
                } else {
                    s0 = 0;
                    e0 = 0;
                }
                var i = d3.interpolate({ startAngle: s0, endAngle: e0 }, { startAngle: d.startAngle, endAngle: d.endAngle });
                return function (t) {
                    var b = i(t);
                    return arc(b);
                };
            }

            function removePieTween(d, i) {
                s0 = 2 * Math.PI;
                e0 = 2 * Math.PI;
                var i = d3.interpolate({ startAngle: d.startAngle, endAngle: d.endAngle }, { startAngle: s0, endAngle: e0 });
                return function (t) {
                    var b = i(t);
                    return arc(b);
                };
            }

            function textTween(d, i) {
                var a;
                if (oldPieData[i]) {
                    a = (oldPieData[i].startAngle + oldPieData[i].endAngle - Math.PI) / 2;
                } else if (!(oldPieData[i]) && oldPieData[i - 1]) {
                    a = (oldPieData[i - 1].startAngle + oldPieData[i - 1].endAngle - Math.PI) / 2;
                } else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
                    a = (oldPieData[oldPieData.length - 1].startAngle + oldPieData[oldPieData.length - 1].endAngle - Math.PI) / 2;
                } else {
                    a = 0;
                }
                var b = (d.startAngle + d.endAngle - Math.PI) / 2;

                var fn = d3.interpolateNumber(a, b);
                return function (t) {
                    var val = fn(t);
                    return "translate(" + Math.cos(val) * (r + textOffset) + "," + Math.sin(val) * (r + textOffset) + ")";
                };
            }
            update();//calls the above code to run,
        });

        //Start the bar graph code

        var margin = { top: 10, right: 40, bottom: 20, left: 50 },
            width = 450 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        var x = d3.scale.ordinal()
            .rangeRoundBands([0, width], .2);

        var y = d3.scale.linear()
            .range([height, 0]);

        var y2 = d3.scale.linear()
            .range([height, 0]);

        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .ticks(5);

        var y2Axis = d3.svg.axis()
            .scale(y2)
            .orient("right")
            .ticks(4, "%");

        var svg = d3.select("#graph").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var line = d3.svg.line()
            .x(function (d) { return x2(d.periodyear); })
            .y(function (d) { return y2(d.changeemp); });

        function roundToOne(num) {//Ensures numbers always display the given number of digits after the decimal
            return +(Math.round(num + "e+1") + "e-1");
        };

        updateBars();

        function updateBars() {
            d3.csv("/static/corAndP.csv", type, function (error, data) {
                if (error) throw error;

                var I = document.getElementById('geo').selectedIndex
                    , select = document.getElementById('geo')[I].value
                    , data = data.filter(function (d) { return d.area == select })
                    , min = (d3.min(data, function (d) { return d.avgemp; }) - (.2 * d3.mean(data, function (d) { return d.avgemp; })))
                    , min2 = 1.2 * d3.min(data, function (d) { return d.changeemp; })
                    , max2 = 1.2 * d3.max(data, function (d) { return d.changeemp; })

                if (min < 1) {//sets axis automatically, but uses zero if the min would be close to 0 anyway
                    var min = 0
                };
                if (min2 >= 0) {
                    var min2 = -.01
                };
                if (max2 <= 0) {
                    var max2 = .01
                };
                //Tufte would be proud of this, if he ever saw it. The economic data
                //of y/y change in employment can take on negitive values, thus we need to
                // ensure the axis always include negitive and positive values

                x.domain(data.map(function (d) { return d.periodyear; }));
                y2.domain([min2, max2]);
                y.domain([min, ((d3.max(data, function (d) { return d.avgemp / 100; }) * 100) + (.11 * d3.mean(data, function (d) { return d.avgemp; })))]);
                //Sets the domain based on the average, making the max .11 times the average greater than the max value, for asthetics only essentually

                if (svg.selectAll(".x.axis")[0].length < 1) {//This stuff only occurs the first time the code is looped through, not subsiquent calls
                    svg.append("g")
                        .attr("class", "x axis")
                        .attr("transform", "translate(0," + height + ")")
                        .call(xAxis);

                    svg.append('g')
                        .attr("class", "y axisL")
                        .call(yAxis)
                      .append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("y", 4)
                        .attr("dy", ".71em")
                        .style("text-anchor", "end")
                        .text("correlation coefficien");

                    svg.append("g")
                        .attr("class", "y axisR")
                        .call(y2Axis)
                        .attr("transform", "translate(" + width + ",0)")
                      .append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -11)
                        .attr("dy", ".71em")
                        .style("text-anchor", "end")
                        .text("P Value");

                    svg.selectAll(".bar")
                        .data(data)
                      .enter()
                        .append("rect")
                        .attr("class", "bar")
                        .attr("x", function (d) { return x(d.periodyear); })
                        .attr("width", x.rangeBand())
                        .attr("y", function (d) { return y(10e-6); })
                        .attr("height", function (d) { return y(10e-6) })
                      .transition()
                        .duration(1050)
                        .attr("y", function (d) { return y(d.avgemp); })
                        .attr("height", function (d) { return height - y(d.avgemp); });

                    svg.selectAll(".chartLine")
                        .data(data)
                      .enter()
                        .append("rect")
                        .attr("class", "chartLine")
                        .attr("transform", "translate(" + 20 + ",0)")
                        .attr("width", x.rangeBand() - 40)
                        .attr("x", function (d) { return x(d.periodyear); })
                        .attr("y", function (d) { return d3.min(data, function (d) { return y2(d.changeemp); }) })
                        .attr("height", function (d) { return 1 })
                      .transition()
                        .duration(1050)
                        .attr("y", function (d) { return y2(d.changeemp); });

                    svg.selectAll(".chartLineText")
                        .data(data)
                      .enter()
                        .append('text')
                        .attr("class", "chartLineText")
                        .style("color", "#000")
                        .style("text-anchor", "middle")
                        .attr("transform", "translate(" + 30 + ",-2)")
                        .attr("x", function (d) { return x(d.periodyear); })
                        .attr("y", function (d) { return d3.min(data, function (d) { return y2(d.changeemp); }) })
                        .text(function (d) { return roundToOne(d.changeemp * 100) + "%" })
                      .transition()
                        .duration(1050)
                        .attr("y", function (d) { return y2(d.changeemp); });

                    svg.selectAll(".barText")
                        .data(data)
                      .enter()
                        .append("text")
                        .attr("class", "barText")
                        .attr("text-anchor", "middle")
                        .attr("transform", "translate(" + x.rangeBand() / 2 + ",-3)")
                        .attr("x", function (d) { return x(d.periodyear); })
                        .text(function (d) { return formatMoney(+d.avgemp) })
                        .attr("y", function (d) { return y(d.avgemp) - 10; });

                } else {//This is what is called when the code is called to update by a change in the drop downs.
                    svg.selectAll(".y.axisL").transition().duration(1500).call(yAxis);
                    svg.selectAll(".y.axisR").transition().duration(1500).call(y2Axis);

                    svg.selectAll(".chartLineText").
                        data(data)
                        .transition()
                        .duration(1500)
                        .attr("y", function (d) { return y2(d.changeemp); })
                        .text(function (d) { return roundToOne(d.changeemp * 100) + "%" });

                    svg.selectAll(".chartLine")
                        .data(data)
                    .transition()
                        .duration(1500)
                        .attr("y", function (d) { return y2(d.changeemp); });

                    svg.selectAll(".bar")
                        .data(data)
                    .transition()
                        .duration(1500)
                        .delay(function (d) { return 100 + (d.periodyear - 2013) * 100 })
                        .attr("y", function (d) { return y(d.avgemp); })
                        .attr("height", function (d) { return height - y(d.avgemp); });

                    svg.selectAll(".barText")
                        .data(data)
                        .transition()
                        .duration(500)
                        .attr("y", function (d) { return y(d.avgemp); })
                        .text(function (d) { return formatMoney(+d.avgemp) });
                };

                d3.selectAll(".bar")
                .on("mouseover", function (d) {
                    d3.selectAll(".barText").transition()
                        .duration(500)
                        .delay(80)
                        //This makes the text lables mostly prevent overlap, it's not perfect, but solves more cases than it breaks, and the values are generally always visable
                        .attr("y", function (d) { if (Math.abs(y2(d.changeemp) - y(d.avgemp)) < 10) { if (y(d.avgemp) - 10 - (y2(d.changeemp)) >= 2) { return y(d.avgemp) - 10 } else { return y(d.avgemp) + 15 } } else { return y(d.avgemp) } })
                        .style("visibility", "visible");
                })
                .on("mouseout", function (d) {
                    d3.selectAll(".barText").transition()
                        .duration(500)
                        .delay(150)
                        .attr("y", function (d) { return y(d.avgemp) - 10; })
                        .style("visibility", "hidden");
                })
            });

            function type(d) {
                d.periodyear = +d.periodyear;
                d.changeemp = +d.changeemp;
                d.avgemp = +d.avgemp;
                return d;
            }
        };
    </script>
</body>
<link href="/static/chart2.css" rel="stylesheet">
</html>